// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: swisstronik/did/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgCreateDIDDocument struct {
	// Payload containing the DID Document to be created
	Payload *MsgCreateDIDDocumentPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// Signatures of the DID Document's controller(s)
	Signatures []*SignInfo `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *MsgCreateDIDDocument) Reset()         { *m = MsgCreateDIDDocument{} }
func (m *MsgCreateDIDDocument) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDIDDocument) ProtoMessage()    {}
func (*MsgCreateDIDDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{0}
}
func (m *MsgCreateDIDDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDIDDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDIDDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDIDDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDIDDocument.Merge(m, src)
}
func (m *MsgCreateDIDDocument) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDIDDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDIDDocument.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDIDDocument proto.InternalMessageInfo

func (m *MsgCreateDIDDocument) GetPayload() *MsgCreateDIDDocumentPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *MsgCreateDIDDocument) GetSignatures() []*SignInfo {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type MsgUpdateDIDDocument struct {
	// Payload containing the DID Document to be updated. This should be updated
	// the DID Document.
	Payload *MsgUpdateDIDDocumentPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// Signatures of the DID Document's controller(s)
	Signatures []*SignInfo `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *MsgUpdateDIDDocument) Reset()         { *m = MsgUpdateDIDDocument{} }
func (m *MsgUpdateDIDDocument) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDIDDocument) ProtoMessage()    {}
func (*MsgUpdateDIDDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{1}
}
func (m *MsgUpdateDIDDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDIDDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDIDDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDIDDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDIDDocument.Merge(m, src)
}
func (m *MsgUpdateDIDDocument) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDIDDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDIDDocument.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDIDDocument proto.InternalMessageInfo

func (m *MsgUpdateDIDDocument) GetPayload() *MsgUpdateDIDDocumentPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *MsgUpdateDIDDocument) GetSignatures() []*SignInfo {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type MsgDeactivateDIDDocument struct {
	// Payload containing the DID Document to be deactivated
	Payload *MsgDeactivateDIDDocumentPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// Signatures of the DID Document's controller(s)
	Signatures []*SignInfo `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *MsgDeactivateDIDDocument) Reset()         { *m = MsgDeactivateDIDDocument{} }
func (m *MsgDeactivateDIDDocument) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateDIDDocument) ProtoMessage()    {}
func (*MsgDeactivateDIDDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{2}
}
func (m *MsgDeactivateDIDDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateDIDDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateDIDDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateDIDDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateDIDDocument.Merge(m, src)
}
func (m *MsgDeactivateDIDDocument) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateDIDDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateDIDDocument.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateDIDDocument proto.InternalMessageInfo

func (m *MsgDeactivateDIDDocument) GetPayload() *MsgDeactivateDIDDocumentPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *MsgDeactivateDIDDocument) GetSignatures() []*SignInfo {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// SignInfo defines the structure of a DID Document controller's signature
type SignInfo struct {
	// Verification method ID of the DID Controller
	VerificationMethodId string `protobuf:"bytes,1,opt,name=verification_method_id,json=verificationMethodId,proto3" json:"verification_method_id,omitempty"`
	// Signature of the DID Document controller
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SignInfo) Reset()         { *m = SignInfo{} }
func (m *SignInfo) String() string { return proto.CompactTextString(m) }
func (*SignInfo) ProtoMessage()    {}
func (*SignInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{3}
}
func (m *SignInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignInfo.Merge(m, src)
}
func (m *SignInfo) XXX_Size() int {
	return m.Size()
}
func (m *SignInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SignInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SignInfo proto.InternalMessageInfo

func (m *SignInfo) GetVerificationMethodId() string {
	if m != nil {
		return m.VerificationMethodId
	}
	return ""
}

func (m *SignInfo) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// MsgCreateDIDDocumentPayload defines the structure of the payload for creating
// a new DID document
type MsgCreateDIDDocumentPayload struct {
	// context is a list of URIs used to identify the context of the DID document.
	// Default: https://www.w3.org/ns/did/v1
	Context []string `protobuf:"bytes,1,rep,name=context,proto3" json:"context,omitempty"`
	// id is the DID of the DID document.
	// Format: did:swtr:<unique-identifier>
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// controller is a list of DIDs that are allowed to control the DID document.
	Controller []string `protobuf:"bytes,3,rep,name=controller,proto3" json:"controller,omitempty"`
	// verificationMethod is a list of verification methods that can be used to
	// verify a digital signature or cryptographic proof.
	// Documentation: https://www.w3.org/TR/did-core/#verification-methods
	//
	// Required fields:
	// - id: A unique identifier for the verification method
	// - type: A supported verification method type (supported:
	// Ed25519VerificationKey2018, Ed25519VerificationKey2020, JsonWebKey2020)
	// - controller: DID of the controller of the verification method
	// - verification_material: Public key of the verification method (supported:
	// publicJwk, publicKeyBase58, publicKeyMultibase)
	VerificationMethod []*VerificationMethod `protobuf:"bytes,4,rep,name=verification_method,json=verificationMethod,proto3" json:"verification_method,omitempty"`
	// authentication is a list of verification methods that can be used to
	// authenticate as the DID subject.
	Authentication []string `protobuf:"bytes,5,rep,name=authentication,proto3" json:"authentication,omitempty"`
	// assertionMethod is a list of verification methods that can be used to
	// assert statements as the DID subject.
	AssertionMethod []string `protobuf:"bytes,6,rep,name=assertion_method,json=assertionMethod,proto3" json:"assertion_method,omitempty"`
	// capabilityInvocation is a list of verification methods that can be used to
	// invoke capabilities as the DID subject.
	CapabilityInvocation []string `protobuf:"bytes,7,rep,name=capability_invocation,json=capabilityInvocation,proto3" json:"capability_invocation,omitempty"`
	// capabilityDelegation is a list of verification methods that can be used to
	// delegate capabilities as the DID subject.
	CapabilityDelegation []string `protobuf:"bytes,8,rep,name=capability_delegation,json=capabilityDelegation,proto3" json:"capability_delegation,omitempty"`
	// keyAgreement is a list of verification methods that can be used to perform
	// key agreement as the DID subject.
	KeyAgreement []string `protobuf:"bytes,9,rep,name=key_agreement,json=keyAgreement,proto3" json:"key_agreement,omitempty"`
	// service is a list of services that can be used to interact with the DID
	// subject. Documentation: https://www.w3.org/TR/did-core/#services
	//
	// Required fields:
	// - id: A unique identifier for the service
	// - type: A service type defined in DID Specification Registries
	// - service_endpoint: Service endpoint(s), provided as a URI or set of URIs
	Service []*Service `protobuf:"bytes,10,rep,name=service,proto3" json:"service,omitempty"`
	// alsoKnownAs is a list of DIDs that are known to refer to the same DID
	// subject.
	AlsoKnownAs []string `protobuf:"bytes,11,rep,name=also_known_as,json=alsoKnownAs,proto3" json:"also_known_as,omitempty"`
	// Version ID of the DID Document to be created
	//
	// Format: <uuid>
	VersionId string `protobuf:"bytes,12,opt,name=version_id,json=versionId,proto3" json:"version_id,omitempty"`
}

func (m *MsgCreateDIDDocumentPayload) Reset()         { *m = MsgCreateDIDDocumentPayload{} }
func (m *MsgCreateDIDDocumentPayload) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDIDDocumentPayload) ProtoMessage()    {}
func (*MsgCreateDIDDocumentPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{4}
}
func (m *MsgCreateDIDDocumentPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDIDDocumentPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDIDDocumentPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDIDDocumentPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDIDDocumentPayload.Merge(m, src)
}
func (m *MsgCreateDIDDocumentPayload) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDIDDocumentPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDIDDocumentPayload.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDIDDocumentPayload proto.InternalMessageInfo

func (m *MsgCreateDIDDocumentPayload) GetContext() []string {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MsgCreateDIDDocumentPayload) GetController() []string {
	if m != nil {
		return m.Controller
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetVerificationMethod() []*VerificationMethod {
	if m != nil {
		return m.VerificationMethod
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetAuthentication() []string {
	if m != nil {
		return m.Authentication
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetAssertionMethod() []string {
	if m != nil {
		return m.AssertionMethod
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetCapabilityInvocation() []string {
	if m != nil {
		return m.CapabilityInvocation
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetCapabilityDelegation() []string {
	if m != nil {
		return m.CapabilityDelegation
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetKeyAgreement() []string {
	if m != nil {
		return m.KeyAgreement
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetService() []*Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetAlsoKnownAs() []string {
	if m != nil {
		return m.AlsoKnownAs
	}
	return nil
}

func (m *MsgCreateDIDDocumentPayload) GetVersionId() string {
	if m != nil {
		return m.VersionId
	}
	return ""
}

// MsgCreateDIDDocumentResponse defines response type for Msg/CreateDIDDocument.
type MsgCreateDIDDocumentResponse struct {
	// Return the created DID Document with metadata
	Value *DIDDocumentWithMetadata `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MsgCreateDIDDocumentResponse) Reset()         { *m = MsgCreateDIDDocumentResponse{} }
func (m *MsgCreateDIDDocumentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDIDDocumentResponse) ProtoMessage()    {}
func (*MsgCreateDIDDocumentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{5}
}
func (m *MsgCreateDIDDocumentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDIDDocumentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDIDDocumentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDIDDocumentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDIDDocumentResponse.Merge(m, src)
}
func (m *MsgCreateDIDDocumentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDIDDocumentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDIDDocumentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDIDDocumentResponse proto.InternalMessageInfo

func (m *MsgCreateDIDDocumentResponse) GetValue() *DIDDocumentWithMetadata {
	if m != nil {
		return m.Value
	}
	return nil
}

// MsgUpdateDIDDocumentPayload defines the structure of the payload for updating
// an existing DID document
type MsgUpdateDIDDocumentPayload struct {
	// context is a list of URIs used to identify the context of the DID document.
	// Default: https://www.w3.org/ns/did/v1
	Context []string `protobuf:"bytes,1,rep,name=context,proto3" json:"context,omitempty"`
	// id is the DID of the DID document.
	// Format: did:swtr:<unique-identifier>
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// controller is a list of DIDs that are allowed to control the DID document.
	Controller []string `protobuf:"bytes,3,rep,name=controller,proto3" json:"controller,omitempty"`
	// verificationMethod is a list of verification methods that can be used to
	// verify a digital signature or cryptographic proof.
	// Documentation: https://www.w3.org/TR/did-core/#verification-methods
	//
	// Required fields:
	// - id: A unique identifier for the verification method
	// - type: A supported verification method type (supported:
	// Ed25519VerificationKey2018, Ed25519VerificationKey2020, JsonWebKey2020)
	// - controller: DID of the controller of the verification method
	// - verification_material: Public key of the verification method (supported:
	// publicJwk, publicKeyBase58, publicKeyMultibase)
	VerificationMethod []*VerificationMethod `protobuf:"bytes,4,rep,name=verification_method,json=verificationMethod,proto3" json:"verification_method,omitempty"`
	// authentication is a list of verification methods that can be used to
	// authenticate as the DID subject.
	Authentication []string `protobuf:"bytes,5,rep,name=authentication,proto3" json:"authentication,omitempty"`
	// assertionMethod is a list of verification methods that can be used to
	// assert statements as the DID subject.
	AssertionMethod []string `protobuf:"bytes,6,rep,name=assertion_method,json=assertionMethod,proto3" json:"assertion_method,omitempty"`
	// capabilityInvocation is a list of verification methods that can be used to
	// invoke capabilities as the DID subject.
	CapabilityInvocation []string `protobuf:"bytes,7,rep,name=capability_invocation,json=capabilityInvocation,proto3" json:"capability_invocation,omitempty"`
	// capabilityDelegation is a list of verification methods that can be used to
	// delegate capabilities as the DID subject.
	CapabilityDelegation []string `protobuf:"bytes,8,rep,name=capability_delegation,json=capabilityDelegation,proto3" json:"capability_delegation,omitempty"`
	// keyAgreement is a list of verification methods that can be used to perform
	// key agreement as the DID subject.
	KeyAgreement []string `protobuf:"bytes,9,rep,name=key_agreement,json=keyAgreement,proto3" json:"key_agreement,omitempty"`
	// service is a list of services that can be used to interact with the DID
	// subject. Documentation: https://www.w3.org/TR/did-core/#services
	//
	// Required fields:
	// - id: A unique identifier for the service
	// - type: A service type defined in DID Specification Registries
	// - service_endpoint: Service endpoint(s), provided as a URI or set of URIs
	Service []*Service `protobuf:"bytes,10,rep,name=service,proto3" json:"service,omitempty"`
	// alsoKnownAs is a list of DIDs that are known to refer to the same DID
	// subject.
	AlsoKnownAs []string `protobuf:"bytes,11,rep,name=also_known_as,json=alsoKnownAs,proto3" json:"also_known_as,omitempty"`
	// Updated version ID of the DID Document.
	// Links to next/previous versions of the DID Document will be automatically
	// updated.
	//
	// Format: <uuid>
	VersionId string `protobuf:"bytes,12,opt,name=version_id,json=versionId,proto3" json:"version_id,omitempty"`
}

func (m *MsgUpdateDIDDocumentPayload) Reset()         { *m = MsgUpdateDIDDocumentPayload{} }
func (m *MsgUpdateDIDDocumentPayload) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDIDDocumentPayload) ProtoMessage()    {}
func (*MsgUpdateDIDDocumentPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{6}
}
func (m *MsgUpdateDIDDocumentPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDIDDocumentPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDIDDocumentPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDIDDocumentPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDIDDocumentPayload.Merge(m, src)
}
func (m *MsgUpdateDIDDocumentPayload) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDIDDocumentPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDIDDocumentPayload.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDIDDocumentPayload proto.InternalMessageInfo

func (m *MsgUpdateDIDDocumentPayload) GetContext() []string {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MsgUpdateDIDDocumentPayload) GetController() []string {
	if m != nil {
		return m.Controller
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetVerificationMethod() []*VerificationMethod {
	if m != nil {
		return m.VerificationMethod
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetAuthentication() []string {
	if m != nil {
		return m.Authentication
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetAssertionMethod() []string {
	if m != nil {
		return m.AssertionMethod
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetCapabilityInvocation() []string {
	if m != nil {
		return m.CapabilityInvocation
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetCapabilityDelegation() []string {
	if m != nil {
		return m.CapabilityDelegation
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetKeyAgreement() []string {
	if m != nil {
		return m.KeyAgreement
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetService() []*Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetAlsoKnownAs() []string {
	if m != nil {
		return m.AlsoKnownAs
	}
	return nil
}

func (m *MsgUpdateDIDDocumentPayload) GetVersionId() string {
	if m != nil {
		return m.VersionId
	}
	return ""
}

type MsgUpdateDIDDocumentResponse struct {
	// Return the updated DID Document with metadata
	Value *DIDDocumentWithMetadata `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MsgUpdateDIDDocumentResponse) Reset()         { *m = MsgUpdateDIDDocumentResponse{} }
func (m *MsgUpdateDIDDocumentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDIDDocumentResponse) ProtoMessage()    {}
func (*MsgUpdateDIDDocumentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{7}
}
func (m *MsgUpdateDIDDocumentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDIDDocumentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDIDDocumentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDIDDocumentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDIDDocumentResponse.Merge(m, src)
}
func (m *MsgUpdateDIDDocumentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDIDDocumentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDIDDocumentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDIDDocumentResponse proto.InternalMessageInfo

func (m *MsgUpdateDIDDocumentResponse) GetValue() *DIDDocumentWithMetadata {
	if m != nil {
		return m.Value
	}
	return nil
}

// MsgDeactivateDIDDocumentPayload defines the structure of the payload for
// deactivating an existing DID document
type MsgDeactivateDIDDocumentPayload struct {
	// Unique identifier of the DID Document to be deactivated
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Version ID of the DID Document to be deactivated
	// This is primarily used as a sanity check to ensure that the correct DID
	// Document is being deactivated.
	VersionId string `protobuf:"bytes,2,opt,name=version_id,json=versionId,proto3" json:"version_id,omitempty"`
}

func (m *MsgDeactivateDIDDocumentPayload) Reset()         { *m = MsgDeactivateDIDDocumentPayload{} }
func (m *MsgDeactivateDIDDocumentPayload) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateDIDDocumentPayload) ProtoMessage()    {}
func (*MsgDeactivateDIDDocumentPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{8}
}
func (m *MsgDeactivateDIDDocumentPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateDIDDocumentPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateDIDDocumentPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateDIDDocumentPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateDIDDocumentPayload.Merge(m, src)
}
func (m *MsgDeactivateDIDDocumentPayload) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateDIDDocumentPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateDIDDocumentPayload.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateDIDDocumentPayload proto.InternalMessageInfo

func (m *MsgDeactivateDIDDocumentPayload) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MsgDeactivateDIDDocumentPayload) GetVersionId() string {
	if m != nil {
		return m.VersionId
	}
	return ""
}

// MsgDeactivateDIDDocumentResponse defines response type for
// Msg/DeactivateDIDDocument.
type MsgDeactivateDIDDocumentResponse struct {
	// Return the deactivated DID Document with metadata
	Value *DIDDocumentWithMetadata `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MsgDeactivateDIDDocumentResponse) Reset()         { *m = MsgDeactivateDIDDocumentResponse{} }
func (m *MsgDeactivateDIDDocumentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateDIDDocumentResponse) ProtoMessage()    {}
func (*MsgDeactivateDIDDocumentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf79adfa645a7210, []int{9}
}
func (m *MsgDeactivateDIDDocumentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateDIDDocumentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateDIDDocumentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateDIDDocumentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateDIDDocumentResponse.Merge(m, src)
}
func (m *MsgDeactivateDIDDocumentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateDIDDocumentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateDIDDocumentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateDIDDocumentResponse proto.InternalMessageInfo

func (m *MsgDeactivateDIDDocumentResponse) GetValue() *DIDDocumentWithMetadata {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*MsgCreateDIDDocument)(nil), "swisstronik.did.MsgCreateDIDDocument")
	proto.RegisterType((*MsgUpdateDIDDocument)(nil), "swisstronik.did.MsgUpdateDIDDocument")
	proto.RegisterType((*MsgDeactivateDIDDocument)(nil), "swisstronik.did.MsgDeactivateDIDDocument")
	proto.RegisterType((*SignInfo)(nil), "swisstronik.did.SignInfo")
	proto.RegisterType((*MsgCreateDIDDocumentPayload)(nil), "swisstronik.did.MsgCreateDIDDocumentPayload")
	proto.RegisterType((*MsgCreateDIDDocumentResponse)(nil), "swisstronik.did.MsgCreateDIDDocumentResponse")
	proto.RegisterType((*MsgUpdateDIDDocumentPayload)(nil), "swisstronik.did.MsgUpdateDIDDocumentPayload")
	proto.RegisterType((*MsgUpdateDIDDocumentResponse)(nil), "swisstronik.did.MsgUpdateDIDDocumentResponse")
	proto.RegisterType((*MsgDeactivateDIDDocumentPayload)(nil), "swisstronik.did.MsgDeactivateDIDDocumentPayload")
	proto.RegisterType((*MsgDeactivateDIDDocumentResponse)(nil), "swisstronik.did.MsgDeactivateDIDDocumentResponse")
}

func init() { proto.RegisterFile("swisstronik/did/tx.proto", fileDescriptor_bf79adfa645a7210) }

var fileDescriptor_bf79adfa645a7210 = []byte{
	// 668 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xad, 0x93, 0xb6, 0x69, 0x6e, 0xfa, 0xf3, 0x75, 0xbe, 0x16, 0x86, 0x52, 0x4c, 0x94, 0xaa,
	0x28, 0x95, 0x20, 0xa5, 0x29, 0x1b, 0x36, 0x48, 0x85, 0x08, 0x29, 0xa0, 0x48, 0x95, 0xf9, 0x93,
	0x58, 0x34, 0x9a, 0x66, 0x6e, 0xd3, 0x51, 0x5c, 0x4f, 0xe4, 0x99, 0xa4, 0xcd, 0x5b, 0xb0, 0x42,
	0x62, 0xc9, 0xdb, 0xb0, 0xac, 0x58, 0xb1, 0x44, 0xed, 0x8b, 0xa0, 0xf8, 0x27, 0x35, 0xb6, 0x0b,
	0x11, 0xca, 0x0e, 0x96, 0x39, 0xf7, 0x9c, 0x3b, 0xc7, 0xd7, 0xc7, 0xb9, 0x03, 0x54, 0x9d, 0x0a,
	0xa5, 0xb4, 0x2b, 0x1d, 0xd1, 0xd9, 0xe6, 0x82, 0x6f, 0xeb, 0xb3, 0x4a, 0xd7, 0x95, 0x5a, 0x92,
	0xa5, 0x48, 0xa5, 0xc2, 0x05, 0x5f, 0x33, 0xe3, 0x54, 0x2e, 0x5b, 0xbd, 0x13, 0x74, 0xb4, 0x2f,
	0x28, 0x7d, 0x32, 0x60, 0xa5, 0xa1, 0xda, 0xcf, 0x5c, 0x64, 0x1a, 0x6b, 0xf5, 0x5a, 0x2d, 0x28,
	0x93, 0xe7, 0x90, 0xeb, 0xb2, 0x81, 0x2d, 0x19, 0xa7, 0x46, 0xd1, 0x28, 0x17, 0xaa, 0xf7, 0x2b,
	0xb1, 0xde, 0x95, 0x34, 0xdd, 0xbe, 0xaf, 0xb1, 0x42, 0x31, 0x79, 0x0c, 0xa0, 0x44, 0xdb, 0x61,
	0xba, 0xe7, 0xa2, 0xa2, 0x99, 0x62, 0xb6, 0x5c, 0xa8, 0xde, 0x4a, 0xb4, 0x7a, 0x25, 0xda, 0x4e,
	0xdd, 0x39, 0x92, 0x56, 0x84, 0x1c, 0x7a, 0x7b, 0xd3, 0xe5, 0x7f, 0xe4, 0x2d, 0xa1, 0x9b, 0xa4,
	0xb7, 0xcf, 0x06, 0xd0, 0x86, 0x6a, 0xd7, 0x90, 0xb5, 0xb4, 0xe8, 0xc7, 0xfc, 0xbd, 0x88, 0xfb,
	0x7b, 0x98, 0xe6, 0x2f, 0x55, 0x3b, 0x49, 0x8f, 0x07, 0x30, 0x17, 0xe2, 0xe4, 0x11, 0xdc, 0xe8,
	0xa3, 0x2b, 0x8e, 0x44, 0x8b, 0x69, 0x21, 0x9d, 0xe6, 0x09, 0xea, 0x63, 0xc9, 0x9b, 0xc2, 0x77,
	0x98, 0xb7, 0x56, 0xa2, 0xd5, 0x86, 0x57, 0xac, 0x73, 0xb2, 0x0e, 0xf9, 0x51, 0x3f, 0x9a, 0x29,
	0x1a, 0xe5, 0x79, 0xeb, 0x0a, 0x28, 0x7d, 0x9c, 0x86, 0xdb, 0xbf, 0xc8, 0x00, 0xa1, 0x90, 0x6b,
	0x49, 0x47, 0xe3, 0x99, 0xa6, 0x46, 0x31, 0x5b, 0xce, 0x5b, 0xe1, 0x4f, 0xb2, 0x08, 0x19, 0xc1,
	0xbd, 0x86, 0x79, 0x2b, 0x23, 0x38, 0x31, 0x01, 0x86, 0x25, 0x57, 0xda, 0x36, 0xba, 0x34, 0xeb,
	0x91, 0x23, 0x08, 0x79, 0x0d, 0xff, 0xa7, 0xb8, 0xa7, 0xd3, 0xde, 0x34, 0x36, 0x12, 0xd3, 0x78,
	0x9b, 0x78, 0x16, 0x8b, 0x24, 0x9f, 0x8f, 0xdc, 0x83, 0x45, 0xd6, 0xd3, 0xc7, 0xe8, 0xe8, 0x00,
	0xa7, 0x33, 0xde, 0xc9, 0x31, 0x94, 0x6c, 0xc1, 0x7f, 0x4c, 0x29, 0x74, 0xa3, 0x47, 0xcf, 0x7a,
	0xcc, 0xa5, 0x11, 0x1e, 0xb4, 0xdc, 0x85, 0xd5, 0x16, 0xeb, 0xb2, 0x43, 0x61, 0x0b, 0x3d, 0x68,
	0x0a, 0xa7, 0x2f, 0x83, 0xce, 0x39, 0x8f, 0xbf, 0x72, 0x55, 0xac, 0x8f, 0x6a, 0x31, 0x11, 0x47,
	0x1b, 0xdb, 0xbe, 0x68, 0x2e, 0x2e, 0xaa, 0x8d, 0x6a, 0x64, 0x03, 0x16, 0x3a, 0x38, 0x68, 0xb2,
	0xb6, 0x8b, 0x38, 0x1c, 0x3a, 0xcd, 0x7b, 0xe4, 0xf9, 0x0e, 0x0e, 0xf6, 0x42, 0x8c, 0x54, 0x21,
	0xa7, 0xd0, 0xed, 0x8b, 0x16, 0x52, 0xf0, 0x66, 0x45, 0x93, 0xc9, 0xf1, 0xeb, 0x56, 0x48, 0x24,
	0x25, 0x58, 0x60, 0xb6, 0x92, 0xcd, 0x8e, 0x23, 0x4f, 0x9d, 0x26, 0x53, 0xb4, 0xe0, 0x35, 0x2e,
	0x0c, 0xc1, 0x97, 0x43, 0x6c, 0x4f, 0x91, 0x3b, 0x00, 0x7d, 0x74, 0xd5, 0x70, 0x1e, 0x82, 0xd3,
	0x79, 0xef, 0x3d, 0xe6, 0x03, 0xa4, 0xce, 0x4b, 0x07, 0xb0, 0x9e, 0x96, 0x0b, 0x0b, 0x55, 0x57,
	0x3a, 0x0a, 0xc9, 0x13, 0x98, 0xe9, 0x33, 0xbb, 0x87, 0xc1, 0xd7, 0x51, 0x4e, 0x98, 0x8a, 0x88,
	0xde, 0x09, 0x7d, 0xdc, 0x40, 0xcd, 0x38, 0xd3, 0xcc, 0xf2, 0x65, 0x61, 0xf0, 0xae, 0xfb, 0xc0,
	0xff, 0x05, 0xef, 0xef, 0x0e, 0x5e, 0x22, 0x17, 0x13, 0x0b, 0xde, 0x3e, 0xdc, 0xfd, 0xcd, 0x1f,
	0x77, 0x90, 0x30, 0x63, 0x94, 0xb0, 0x9f, 0x1d, 0x67, 0xe2, 0x8e, 0x0f, 0xa1, 0x78, 0x5d, 0xc7,
	0x49, 0xb9, 0xae, 0x7e, 0xcd, 0x40, 0xb6, 0xa1, 0xda, 0x44, 0xc0, 0x72, 0x72, 0xcf, 0x6f, 0x8e,
	0xb5, 0xd6, 0xd7, 0x1e, 0x8c, 0x45, 0x1b, 0x59, 0x16, 0xb0, 0x9c, 0x5c, 0xdb, 0x9b, 0x63, 0x6d,
	0xe9, 0xf4, 0xa3, 0xae, 0x7f, 0xa7, 0x3d, 0x58, 0x4d, 0xdf, 0xc2, 0x5b, 0x63, 0x2f, 0xdd, 0xb5,
	0x9d, 0xb1, 0xa9, 0xe1, 0xb1, 0x4f, 0x77, 0xbe, 0x5c, 0x98, 0xc6, 0xf9, 0x85, 0x69, 0x7c, 0xbf,
	0x30, 0x8d, 0x0f, 0x97, 0xe6, 0xd4, 0xf9, 0xa5, 0x39, 0xf5, 0xed, 0xd2, 0x9c, 0x7a, 0x7f, 0x33,
	0x7a, 0xe5, 0x3a, 0xf3, 0xef, 0x67, 0x83, 0x2e, 0xaa, 0xc3, 0x59, 0xef, 0xca, 0xb5, 0xfb, 0x23,
	0x00, 0x00, 0xff, 0xff, 0x45, 0x16, 0x2b, 0x4e, 0xbf, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	CreateDIDDocument(ctx context.Context, in *MsgCreateDIDDocument, opts ...grpc.CallOption) (*MsgCreateDIDDocumentResponse, error)
	UpdateDIDDocument(ctx context.Context, in *MsgUpdateDIDDocument, opts ...grpc.CallOption) (*MsgUpdateDIDDocumentResponse, error)
	DeactivateDIDDocument(ctx context.Context, in *MsgDeactivateDIDDocument, opts ...grpc.CallOption) (*MsgDeactivateDIDDocumentResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateDIDDocument(ctx context.Context, in *MsgCreateDIDDocument, opts ...grpc.CallOption) (*MsgCreateDIDDocumentResponse, error) {
	out := new(MsgCreateDIDDocumentResponse)
	err := c.cc.Invoke(ctx, "/swisstronik.did.Msg/CreateDIDDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDIDDocument(ctx context.Context, in *MsgUpdateDIDDocument, opts ...grpc.CallOption) (*MsgUpdateDIDDocumentResponse, error) {
	out := new(MsgUpdateDIDDocumentResponse)
	err := c.cc.Invoke(ctx, "/swisstronik.did.Msg/UpdateDIDDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeactivateDIDDocument(ctx context.Context, in *MsgDeactivateDIDDocument, opts ...grpc.CallOption) (*MsgDeactivateDIDDocumentResponse, error) {
	out := new(MsgDeactivateDIDDocumentResponse)
	err := c.cc.Invoke(ctx, "/swisstronik.did.Msg/DeactivateDIDDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	CreateDIDDocument(context.Context, *MsgCreateDIDDocument) (*MsgCreateDIDDocumentResponse, error)
	UpdateDIDDocument(context.Context, *MsgUpdateDIDDocument) (*MsgUpdateDIDDocumentResponse, error)
	DeactivateDIDDocument(context.Context, *MsgDeactivateDIDDocument) (*MsgDeactivateDIDDocumentResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateDIDDocument(ctx context.Context, req *MsgCreateDIDDocument) (*MsgCreateDIDDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDIDDocument not implemented")
}
func (*UnimplementedMsgServer) UpdateDIDDocument(ctx context.Context, req *MsgUpdateDIDDocument) (*MsgUpdateDIDDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDIDDocument not implemented")
}
func (*UnimplementedMsgServer) DeactivateDIDDocument(ctx context.Context, req *MsgDeactivateDIDDocument) (*MsgDeactivateDIDDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateDIDDocument not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateDIDDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDIDDocument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDIDDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swisstronik.did.Msg/CreateDIDDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDIDDocument(ctx, req.(*MsgCreateDIDDocument))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDIDDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDIDDocument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDIDDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swisstronik.did.Msg/UpdateDIDDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDIDDocument(ctx, req.(*MsgUpdateDIDDocument))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeactivateDIDDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeactivateDIDDocument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeactivateDIDDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swisstronik.did.Msg/DeactivateDIDDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeactivateDIDDocument(ctx, req.(*MsgDeactivateDIDDocument))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "swisstronik.did.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDIDDocument",
			Handler:    _Msg_CreateDIDDocument_Handler,
		},
		{
			MethodName: "UpdateDIDDocument",
			Handler:    _Msg_UpdateDIDDocument_Handler,
		},
		{
			MethodName: "DeactivateDIDDocument",
			Handler:    _Msg_DeactivateDIDDocument_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "swisstronik/did/tx.proto",
}

func (m *MsgCreateDIDDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDIDDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDIDDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDIDDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDIDDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDIDDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateDIDDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateDIDDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateDIDDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerificationMethodId) > 0 {
		i -= len(m.VerificationMethodId)
		copy(dAtA[i:], m.VerificationMethodId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VerificationMethodId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDIDDocumentPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDIDDocumentPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDIDDocumentPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VersionId) > 0 {
		i -= len(m.VersionId)
		copy(dAtA[i:], m.VersionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VersionId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AlsoKnownAs) > 0 {
		for iNdEx := len(m.AlsoKnownAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlsoKnownAs[iNdEx])
			copy(dAtA[i:], m.AlsoKnownAs[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AlsoKnownAs[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Service) > 0 {
		for iNdEx := len(m.Service) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Service[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.KeyAgreement) > 0 {
		for iNdEx := len(m.KeyAgreement) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyAgreement[iNdEx])
			copy(dAtA[i:], m.KeyAgreement[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.KeyAgreement[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CapabilityDelegation) > 0 {
		for iNdEx := len(m.CapabilityDelegation) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapabilityDelegation[iNdEx])
			copy(dAtA[i:], m.CapabilityDelegation[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CapabilityDelegation[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CapabilityInvocation) > 0 {
		for iNdEx := len(m.CapabilityInvocation) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapabilityInvocation[iNdEx])
			copy(dAtA[i:], m.CapabilityInvocation[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CapabilityInvocation[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.AssertionMethod) > 0 {
		for iNdEx := len(m.AssertionMethod) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AssertionMethod[iNdEx])
			copy(dAtA[i:], m.AssertionMethod[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AssertionMethod[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Authentication) > 0 {
		for iNdEx := len(m.Authentication) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Authentication[iNdEx])
			copy(dAtA[i:], m.Authentication[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Authentication[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.VerificationMethod) > 0 {
		for iNdEx := len(m.VerificationMethod) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VerificationMethod[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Controller) > 0 {
		for iNdEx := len(m.Controller) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Controller[iNdEx])
			copy(dAtA[i:], m.Controller[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Controller[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Context) > 0 {
		for iNdEx := len(m.Context) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Context[iNdEx])
			copy(dAtA[i:], m.Context[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Context[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDIDDocumentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDIDDocumentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDIDDocumentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDIDDocumentPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDIDDocumentPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDIDDocumentPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VersionId) > 0 {
		i -= len(m.VersionId)
		copy(dAtA[i:], m.VersionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VersionId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AlsoKnownAs) > 0 {
		for iNdEx := len(m.AlsoKnownAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlsoKnownAs[iNdEx])
			copy(dAtA[i:], m.AlsoKnownAs[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AlsoKnownAs[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Service) > 0 {
		for iNdEx := len(m.Service) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Service[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.KeyAgreement) > 0 {
		for iNdEx := len(m.KeyAgreement) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyAgreement[iNdEx])
			copy(dAtA[i:], m.KeyAgreement[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.KeyAgreement[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CapabilityDelegation) > 0 {
		for iNdEx := len(m.CapabilityDelegation) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapabilityDelegation[iNdEx])
			copy(dAtA[i:], m.CapabilityDelegation[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CapabilityDelegation[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CapabilityInvocation) > 0 {
		for iNdEx := len(m.CapabilityInvocation) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapabilityInvocation[iNdEx])
			copy(dAtA[i:], m.CapabilityInvocation[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CapabilityInvocation[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.AssertionMethod) > 0 {
		for iNdEx := len(m.AssertionMethod) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AssertionMethod[iNdEx])
			copy(dAtA[i:], m.AssertionMethod[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AssertionMethod[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Authentication) > 0 {
		for iNdEx := len(m.Authentication) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Authentication[iNdEx])
			copy(dAtA[i:], m.Authentication[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Authentication[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.VerificationMethod) > 0 {
		for iNdEx := len(m.VerificationMethod) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VerificationMethod[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Controller) > 0 {
		for iNdEx := len(m.Controller) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Controller[iNdEx])
			copy(dAtA[i:], m.Controller[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Controller[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Context) > 0 {
		for iNdEx := len(m.Context) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Context[iNdEx])
			copy(dAtA[i:], m.Context[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Context[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDIDDocumentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDIDDocumentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDIDDocumentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateDIDDocumentPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateDIDDocumentPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateDIDDocumentPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VersionId) > 0 {
		i -= len(m.VersionId)
		copy(dAtA[i:], m.VersionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VersionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateDIDDocumentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateDIDDocumentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateDIDDocumentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateDIDDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateDIDDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgDeactivateDIDDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *SignInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VerificationMethodId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateDIDDocumentPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Context) > 0 {
		for _, s := range m.Context {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Controller) > 0 {
		for _, s := range m.Controller {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.VerificationMethod) > 0 {
		for _, e := range m.VerificationMethod {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Authentication) > 0 {
		for _, s := range m.Authentication {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.AssertionMethod) > 0 {
		for _, s := range m.AssertionMethod {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CapabilityInvocation) > 0 {
		for _, s := range m.CapabilityInvocation {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CapabilityDelegation) > 0 {
		for _, s := range m.CapabilityDelegation {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.KeyAgreement) > 0 {
		for _, s := range m.KeyAgreement {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Service) > 0 {
		for _, e := range m.Service {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.AlsoKnownAs) > 0 {
		for _, s := range m.AlsoKnownAs {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.VersionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateDIDDocumentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDIDDocumentPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Context) > 0 {
		for _, s := range m.Context {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Controller) > 0 {
		for _, s := range m.Controller {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.VerificationMethod) > 0 {
		for _, e := range m.VerificationMethod {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Authentication) > 0 {
		for _, s := range m.Authentication {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.AssertionMethod) > 0 {
		for _, s := range m.AssertionMethod {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CapabilityInvocation) > 0 {
		for _, s := range m.CapabilityInvocation {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CapabilityDelegation) > 0 {
		for _, s := range m.CapabilityDelegation {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.KeyAgreement) > 0 {
		for _, s := range m.KeyAgreement {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Service) > 0 {
		for _, e := range m.Service {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.AlsoKnownAs) > 0 {
		for _, s := range m.AlsoKnownAs {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.VersionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDIDDocumentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeactivateDIDDocumentPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.VersionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeactivateDIDDocumentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateDIDDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDIDDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDIDDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &MsgCreateDIDDocumentPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &SignInfo{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDIDDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDIDDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDIDDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &MsgUpdateDIDDocumentPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &SignInfo{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateDIDDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateDIDDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateDIDDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &MsgDeactivateDIDDocumentPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &SignInfo{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationMethodId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationMethodId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDIDDocumentPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDIDDocumentPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDIDDocumentPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = append(m.Controller, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationMethod = append(m.VerificationMethod, &VerificationMethod{})
			if err := m.VerificationMethod[len(m.VerificationMethod)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authentication = append(m.Authentication, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssertionMethod = append(m.AssertionMethod, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapabilityInvocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapabilityInvocation = append(m.CapabilityInvocation, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapabilityDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapabilityDelegation = append(m.CapabilityDelegation, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAgreement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAgreement = append(m.KeyAgreement, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = append(m.Service, &Service{})
			if err := m.Service[len(m.Service)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlsoKnownAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlsoKnownAs = append(m.AlsoKnownAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDIDDocumentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDIDDocumentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDIDDocumentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &DIDDocumentWithMetadata{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDIDDocumentPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDIDDocumentPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDIDDocumentPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = append(m.Controller, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationMethod = append(m.VerificationMethod, &VerificationMethod{})
			if err := m.VerificationMethod[len(m.VerificationMethod)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authentication = append(m.Authentication, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssertionMethod = append(m.AssertionMethod, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapabilityInvocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapabilityInvocation = append(m.CapabilityInvocation, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapabilityDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapabilityDelegation = append(m.CapabilityDelegation, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAgreement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAgreement = append(m.KeyAgreement, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = append(m.Service, &Service{})
			if err := m.Service[len(m.Service)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlsoKnownAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlsoKnownAs = append(m.AlsoKnownAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDIDDocumentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDIDDocumentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDIDDocumentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &DIDDocumentWithMetadata{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateDIDDocumentPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateDIDDocumentPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateDIDDocumentPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateDIDDocumentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateDIDDocumentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateDIDDocumentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &DIDDocumentWithMetadata{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
